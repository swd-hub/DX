<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Data Viewer - Card Database</title>
    <style>
        :root {
            --primary: #4f46e5;
            --bg: #f8fafc;
            --card: #ffffff;
            --border: #e2e8f0;
            --text-main: #1e293b;
            --sidebar-width: 320px;
            --right-sidebar-width: 280px;
        }

        body {
            font-family: "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            margin: 0;
            overflow: hidden;
            display: flex;
        }

        /* Êìç‰Ωú„Éë„Éç„É´Ôºà„Éâ„É≠„ÉØ„ÉºÔºâ */
        #sidebar {
            width: var(--sidebar-width);
            height: 100vh;
            background: #fff;
            border-right: 1px solid var(--border);
            position: fixed;
            left: calc(-1 * var(--sidebar-width));
            top: 0;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.1);
        }

        #sidebar.open {
            transform: translateX(var(--sidebar-width));
        }

        /* „É°„Ç§„É≥„Ç®„É™„Ç¢ */
        #main-content {
            flex: 1;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: 0.3s;
            padding: 20px;
            box-sizing: border-box;
        }

        /* „Éà„Ç∞„É´„Éú„Çø„É≥ */
        .toggle-btn {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1100;
            background: var(--text-main);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }

        .toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        /* Â∑®Â§ßÂåñ„Åó„Åü„Ç´„Éº„Éâ */
        .db-card {
            background: var(--card);
            width: 95%;
            max-width: 1250px;
            /* Adjusted for ~3 columns */
            height: 90vh;
            padding: 40px;
            border-radius: 28px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15);
            border-top: 12px solid var(--primary);
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        .card-header {
            border-bottom: 3px solid var(--bg);
            margin-bottom: 20px;
            padding-bottom: 10px;
            /* Revert flex to align left (stacked) */
            /* display: flex; justify-content: space-between; align-items: center; */
        }

        /* Âè≥„Çµ„Ç§„Éâ„Éê„Éº (ÂêçÂâç„É™„Çπ„Éà) */
        #right-sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: var(--right-sidebar-width);
            height: 100vh;
            background: var(--card);
            border-left: 1px solid var(--border);
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            z-index: 1000;
            transition: transform 0.3s ease;
        }

        .right-sidebar-toggle {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 1100;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            cursor: pointer;
            font-weight: 700;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2);
            display: none;
            /* Mobile only or optional */
        }

        .name-list-group {
            margin-bottom: 20px;
        }

        .name-list-header {
            font-size: 0.8rem;
            font-weight: 800;
            color: var(--primary);
            background: #f1f5f9;
            padding: 4px 10px;
            border-radius: 4px;
            margin-bottom: 8px;
            position: sticky;
            top: -20px;
            z-index: 10;
        }

        .name-item {
            padding: 8px 12px;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            color: var(--text-main);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .name-item:hover {
            background: rgba(79, 70, 229, 0.05);
            color: var(--primary);
        }

        .name-item.active {
            background: var(--primary);
            color: white;
            font-weight: 700;
        }

        .name-item .furigana-hint {
            font-size: 0.7rem;
            opacity: 0.6;
            margin-left: 4px;
        }

        .card-header h1 {
            font-size: 2.5rem;
            margin: 0;
            color: var(--text-main);
            letter-spacing: -0.02em;
        }

        .card-body {
            flex: 1;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            /* Force ~3 columns */
            gap: 20px;
            padding-right: 10px;
        }

        .card-field {
            background: #fdfdfd;
            border: 1px solid #f1f5f9;
            padding: 15px;
            /* Reduced padding */
            border-radius: 12px;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
        }

        .card-field:hover {
            border-color: var(--primary);
            background: #fff;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.1);
        }

        .card-field.dragging {
            opacity: 0.6;
        }

        .card-field .card-field-handle {
            cursor: grab;
            color: #94a3b8;
            font-size: 1rem;
            user-select: none;
            margin-bottom: 4px;
        }

        .card-field .card-field-handle:active {
            cursor: grabbing;
        }

        .field-label {
            font-size: 0.85rem;
            color: var(--primary);
            font-weight: 800;
            margin-bottom: 10px;
            letter-spacing: 0.05em;
        }

        .field-value {
            font-size: 1.3rem;
            line-height: 1.4;
            color: #1e293b;
            font-weight: 500;
            word-break: break-word;
            flex-grow: 1;
        }

        .field-date {
            font-size: 1.1rem;
            color: #4f46e5;
            margin-top: 12px;
            font-family: monospace;
            font-weight: 600;
            padding-top: 12px;
            border-top: 1px solid #e2e8f0;
        }

        .field-age {
            font-size: 0.9rem;
            color: #64748b;
            margin-top: 4px;
            font-weight: 500;
        }

        /* „Éö„Éº„Ç∏Êìç‰Ωú */
        .nav-controls {
            display: flex;
            align-items: center;
            gap: 40px;
            margin-top: 30px;
        }

        .btn {
            padding: 15px 35px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 70, 229, 0.4);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-outline {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
        }

        .btn-outline:hover {
            background: rgba(79, 70, 229, 0.08);
        }

        /* Ë®≠ÂÆöÈ†ÖÁõÆ */
        textarea {
            width: 100%;
            height: 120px;
            margin-bottom: 20px;
            border-radius: 12px;
            border: 2px dashed var(--border);
            padding: 15px;
            font-size: 0.85rem;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
            user-select: text;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .setting-section {
            margin-bottom: 30px;
        }

        .setting-section h3 {
            font-size: 0.9rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 5px;
            margin-bottom: 15px;
            color: var(--primary);
            font-weight: 800;
        }

        input[type="text"],
        input[type="date"] {
            font-family: inherit;
        }

        input[type="text"]:focus,
        input[type="date"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        label {
            cursor: pointer;
            user-select: none;
        }

        input[type="checkbox"] {
            cursor: pointer;
            accent-color: var(--primary);
        }

        /* „Çπ„ÇØ„É≠„Éº„É´„Éê„Éº */
        .card-body::-webkit-scrollbar {
            width: 8px;
        }

        .card-body::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }

        .card-body::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .card-body::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        #sidebar::-webkit-scrollbar {
            width: 6px;
        }

        #sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #sidebar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        #sidebar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Á©∫Áä∂ÊÖã„É°„ÉÉ„Çª„Éº„Ç∏ */
        .empty-state {
            text-align: center;
            color: #94a3b8;
            font-size: 1.1rem;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        /* ===== „ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„ÇπË®≠ÂÆöÈ†ÖÁõÆ„Çπ„Çø„Ç§„É´ ===== */
        .setting-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: #f8fafc;
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .setting-item:hover {
            background: #f1f5f9;
            border-color: var(--primary);
        }

        .setting-item input[type="checkbox"] {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .setting-item label {
            flex: 1;
            font-size: 0.9rem;
            color: var(--text-main);
            font-weight: 500;
            margin: 0;
            cursor: pointer;
        }

        /* „Éò„ÉÉ„ÉÄË®≠ÂÆö„ÅÆ„Ç≥„É≥„ÉÜ„Éä */
        #headerSettings {
            max-height: 350px;
            overflow-y: auto;
        }

        .header-setting-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            background: #f8fafc;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .header-setting-item:hover {
            background: #f1f5f9;
            border-color: var(--border);
        }

        .header-setting-item input[type="checkbox"] {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
        }

        .header-setting-item input[type="text"] {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.85rem;
            box-sizing: border-box;
        }

        .header-setting-item input[type="text"]:focus {
            border-color: var(--primary);
            outline: none;
        }

        .birthdate-group {
            margin-bottom: 16px;
        }

        .age-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            margin-left: 24px;
            margin-bottom: 8px;
            margin-top: -4px;
            background: #f8fafc;
            border: 1px solid var(--border);
            border-radius: 8px;
        }

        .age-checkbox input[type="checkbox"] {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .age-checkbox label {
            flex: 1;
            font-size: 0.9rem;
            color: var(--text-main);
            font-weight: 500;
            margin: 0;
            cursor: pointer;
        }

        /* „Éó„É™„É≥„ÉàÂØæÂøú */
        @media print {

            .toggle-btn,
            #sidebar,
            .nav-controls {
                display: none !important;
            }

            #main-content {
                padding: 0;
            }

            #right-sidebar {
                display: none !important;
            }

            .db-card {
                width: 100%;
                height: auto;
                max-width: 100%;
                box-shadow: none;
                border: 1px solid #000;
                page-break-inside: avoid;
            }

            body {
                padding: 0;
            }
        }

        @media (max-width: 1024px) {
            #right-sidebar {
                transform: translateX(100%);
            }

            #right-sidebar.open {
                transform: translateX(0);
            }

            .right-sidebar-toggle {
                display: block;
            }

            #main-content {
                margin-right: 0 !important;
            }
        }

        /* „É¨„Çπ„Éù„É≥„Ç∑„Éñ */
        @media (max-width: 768px) {
            :root {
                --sidebar-width: 100%;
            }

            .db-card {
                padding: 40px 30px;
                height: auto;
                min-height: 80vh;
            }

            .card-header h1 {
                font-size: 2rem;
            }

            .card-body {
                grid-template-columns: 1fr;
            }

            .nav-controls {
                flex-wrap: wrap;
                gap: 20px;
                justify-content: center;
            }
        }
    </style>
</head>

<body>

    <button class="toggle-btn" onclick="toggleSidebar()">‚ò∞ Ë®≠ÂÆö</button>

    <div id="sidebar">
        <h2 style="margin-top: 40px; font-size: 1.5rem; color: var(--text-main);">Ë®≠ÂÆö„Éë„Éç„É´</h2>

        <div class="setting-section">
            <h3>1Ô∏è‚É£ indexDATABASE</h3>
            <p style="font-size: 0.75rem; color: #64748b; margin: 0 0 10px 0;">CSV„ÇíË≤º„Çä‰ªò„Åë„Çã„Åã„ÄÅ„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„Åß„Éï„Ç°„Ç§„É´ÈÅ∏Êäû</p>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                <label for="indexDATABASE"
                    style="font-size: 0.75rem; color: var(--primary); font-weight: 700; margin:0;">indexDATABASE</label>
                <button type="button" onclick="clearData()"
                    style="font-size:0.7rem; padding:4px 8px; border:1px solid var(--border); background:#fff; border-radius:4px; cursor:pointer; color:#64748b;">„ÇØ„É™„Ç¢</button>
            </div>
            <textarea id="indexDATABASE" ondblclick="document.getElementById('fileHidden').click()"
                oninput="processData()" placeholder="Âπ¥ÊúàÊó•,ÂêçÂâç,È†ÖÁõÆ,ÂÜÖÂÆπ&#10;„ÅÆÂΩ¢Âºè„ÅßCSV„ÇíË≤º„Çä‰ªò„Åë"></textarea>
            <input type="file" id="fileHidden" style="display:none" accept=".csv,.txt" onchange="handleFile(event)">

            <div class="setting-item">
                <input type="checkbox" id="enableDedup" checked onchange="processData()">
                <label for="enableDedup">ÂêÑÈ†ÖÁõÆ„ÅÆÊúÄÁµÇÊõ¥Êñ∞Êó•„Éá„Éº„Çø„ÅÆ„ÅøÊäΩÂá∫</label>
            </div>
        </div>

        <div class="setting-section">
            <h3>2Ô∏è‚É£ Áµû„ÇäËæº„ÅøÊù°‰ª∂</h3>
            <input type="text" id="globalSearch"
                style="width:100%; padding:12px; margin-bottom:10px; border:1px solid var(--border); border-radius:8px; box-sizing: border-box;"
                placeholder="ÂêçÂâç„ÇíÊ§úÁ¥¢..." oninput="renderView()">
            <p style="font-size: 0.75rem; margin: 10px 0 5px 0; color: #64748b;">Âπ¥ÈΩ¢Ë®àÁÆó„ÅÆÂü∫Ê∫ñÊó•:</p>
            <input type="date" id="dateFilter"
                style="width:100%; padding:12px; border:1px solid var(--border); border-radius:8px; box-sizing: border-box;"
                onchange="renderView()">
        </div>

        <div class="setting-section">
            <h3>3Ô∏è‚É£ Ë°®Á§∫È†ÖÁõÆ„ÅÆË®≠ÂÆö</h3>
            <p style="font-size: 0.75rem; color: #64748b; margin: 0 0 8px 0;">Ë°®Á§∫ÁîªÈù¢„ÅÆ„Ç´„Éº„Éâ‰∏ä„Åß„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶‰∏¶„Å≥Êõø„Åà„Éª‰∏¶„Å≥„ÅØËá™Âãï‰øùÂ≠ò</p>
            <div style="display:flex; gap:10px; margin-bottom:10px;">
                <button type="button" onclick="toggleAllHeaders(true)"
                    style="font-size:0.75rem; padding:4px 8px; cursor:pointer;">ÂÖ®„Å¶„ÉÅ„Çß„ÉÉ„ÇØ</button>
                <button type="button" onclick="toggleAllHeaders(false)"
                    style="font-size:0.75rem; padding:4px 8px; cursor:pointer;">ÂÖ®„Å¶Ëß£Èô§</button>
            </div>
            <div id="headerSettings"></div>
            <button type="button" class="btn btn-outline" id="btnResetOrder" onclick="resetColumnOrder()"
                style="margin-top:10px; display:none;">‰∏¶„Å≥„ÇíËß£Èô§</button>
        </div>

        <div class="setting-section" style="border-top: 2px solid var(--border); padding-top: 20px;">
            <p style="font-size: 0.75rem; color: #94a3b8; margin: 0;">
                <strong id="statsRecords">0</strong> ‰ª∂„ÅÆ„É¨„Ç≥„Éº„ÉâË™≠ËæºÊ∏à„Åø<br>
                <strong id="statsPeople">0</strong> Âêç„ÅÆ‰∫∫Áâ©<br>
                <strong id="statsItems">0</strong> ÂÄã„ÅÆÈ†ÖÁõÆ
            </p>
        </div>
    </div>

    <div id="right-sidebar">
        <h3
            style="font-size: 1rem; color: var(--text-main); margin-bottom: 15px; border-bottom: 2px solid var(--primary); padding-bottom: 5px;">
            üë§ ÂêçÂâç„ÅÆÁ¥¢Âºï
        </h3>
        <div id="nameListContainer"></div>
    </div>

    <button class="right-sidebar-toggle" onclick="toggleRightSidebar()">üë§</button>

    <div id="main-content" style="margin-right: var(--right-sidebar-width); transition: 0.3s;">
        <div id="cardView" style="width: 100%; display: flex; justify-content: center; align-items: center;">
            <div class="empty-state">
                <div class="empty-state-icon">üìã</div>
                <p>CSV„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Çì„Åß„Åè„Å†„Åï„ÅÑ</p>
            </div>
        </div>

        <div class="nav-controls">
            <button class="btn btn-primary" onclick="changePage(-1)">‚óÄ PREV</button>
            <span id="pageInfo"
                style="font-size: 1.5rem; font-weight: 800; font-family: 'Courier New', Courier, monospace; min-width: 100px; text-align: center;">0
                / 0</span>
            <button class="btn btn-primary" onclick="changePage(1)">NEXT ‚ñ∂</button>
        </div>
    </div>

    <script>
        // ===== State Management =====
        const COLUMN_ORDER_KEY = 'dataViewer_indexDATABASE_columnOrder';
        let rawRecords = [];
        let headerConfigs = [];
        let currentIndex = 0;
        let filteredPeople = [];
        let ageShowFlags = {};
        let draggedIndex = null;

        const BIRTHDATE_KEYWORDS = ['ÁîüÂπ¥ÊúàÊó•', 'ÁîüÂπ¥Êúà', 'ÁîüÂπ¥', 'birthdate', 'birth', 'Ë™ïÁîüÊó•', 'birthday'];
        const FURIGANA_KEYWORDS = ['„Åµ„Çä„Åå„Å™', '„Éï„É™„Ç¨„Éä', 'Ë™≠„Åø', '„Çà„Åø', 'furigana', 'yomi'];


        function saveColumnOrder() {
            if (headerConfigs.length === 0) return;
            try {
                // Save full config including alias, active, and showAge
                const dataToSave = headerConfigs.map(c => ({
                    raw: c.raw,
                    alias: c.alias,
                    active: c.active,
                    showAge: c.showAge || false,
                    ageAlias: c.ageAlias || 'Âπ¥ÈΩ¢'
                }));
                localStorage.setItem(COLUMN_ORDER_KEY, JSON.stringify(dataToSave));
                document.getElementById('btnResetOrder').style.display = '';
            } catch (e) { }
        }

        function loadColumnOrder() {
            try {
                const s = localStorage.getItem(COLUMN_ORDER_KEY);
                return s ? JSON.parse(s) : null;
            } catch (e) { return null; }
        }


        function toggleAllHeaders(activeState) {
            headerConfigs.forEach(c => c.active = activeState);
            renderHeaderSettings();
            renderView();
            saveColumnOrder();
        }

        function resetColumnOrder() {
            try { localStorage.removeItem(COLUMN_ORDER_KEY); } catch (e) { }
            document.getElementById('btnResetOrder').style.display = 'none';
            processData(); // Re-process to reset to default state
        }

        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('open');
            if (document.getElementById('sidebar').classList.contains('open')) {
                document.addEventListener('click', closeSidebarOnClickOutside);
            } else {
                document.removeEventListener('click', closeSidebarOnClickOutside);
            }
        }

        function closeSidebarOnClickOutside(e) {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.querySelector('.toggle-btn');
            if (!sidebar.contains(e.target) && !toggleBtn.contains(e.target)) {
                sidebar.classList.remove('open');
                document.removeEventListener('click', closeSidebarOnClickOutside);
            }
        }

        function handleFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                document.getElementById('indexDATABASE').value = event.target.result;
                processData();
            };
            reader.onerror = () => {
                alert('„Éï„Ç°„Ç§„É´Ë™≠Ëæº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
            };
            reader.readAsText(file, 'UTF-8');
        }

        function parseDate(dateStr) {
            console.log(`parseDate input: "${dateStr}"`);
            const wareki = {
                'S': 1926, 'H': 1989, 'R': 2019
            };

            let normalized = dateStr.trim();

            // ÂíåÊö¶„Éë„Çø„Éº„É≥ (S=1926, H=1989, R=2019)
            // Example: R1 = 2019, R2 = 2020. Logic: Base + Year - 1.
            const warekiMatch = normalized.match(/^([SHR])(\d+)\.(\d+)\.(\d+)$/);
            if (warekiMatch) {
                const [, era, year, month, day] = warekiMatch;
                const baseYear = wareki[era];
                const yyyy = baseYear + parseInt(year) - 1;
                normalized = `${yyyy}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            }

            // Remove JP characters and slash
            normalized = normalized.replace(/[Âπ¥ÊúàÊó•]/g, '-').replace(/-$/, '').replace(/\//g, '-');
            // Remove double hyphens if any (e.g. from "Âπ¥" and "Êúà" replacement)
            normalized = normalized.replace(/--/g, '-');

            const date = new Date(normalized);
            const isValid = !isNaN(date.getTime());
            console.log(`  -> normalized: "${normalized}", valid: ${isValid}, timestamp: ${isValid ? date.getTime() : 'NaN'}`);

            return {
                str: normalized,
                ts: isValid ? date.getTime() : 0,
                valid: isValid,
                date: date
            };
        }

        function calculateAge(birthDateStr, referenceDateVal) {
            console.log(`calculateAge input: "${birthDateStr}", ref: "${referenceDateVal}"`);
            const birthDate = parseDate(birthDateStr);

            if (!birthDate.valid) {
                console.warn('  -> Invalid birth date');
                return null;
            }

            const refDate = referenceDateVal ? new Date(referenceDateVal) : new Date();
            if (isNaN(refDate.getTime())) {
                console.warn('  -> Invalid reference date');
                return null;
            }

            const birth = birthDate.date;

            let age = refDate.getFullYear() - birth.getFullYear();
            const monthDiff = refDate.getMonth() - birth.getMonth();

            if (monthDiff < 0 || (monthDiff === 0 && refDate.getDate() < birth.getDate())) {
                age--;
            }

            console.log(`  -> Calculated age: ${age}`);
            return age >= 0 ? age : null;
        }

        function isBirthdateField(itemName) {
            const lower = itemName.toLowerCase();
            return BIRTHDATE_KEYWORDS.some(keyword => lower.includes(keyword));
        }

        function isFuriganaField(itemName) {
            const lower = itemName.toLowerCase();
            return FURIGANA_KEYWORDS.some(keyword => lower.includes(keyword));
        }

        function getFurigana(person) {
            const furiganaKey = Object.keys(person.records).find(k => isFuriganaField(k));
            if (furiganaKey && person.records[furiganaKey]) {
                const content = person.records[furiganaKey].content;
                if (content && content.trim()) return content.trim();
            }
            return person.name; // Fallback to name if no furigana found
        }

        function getFuriganaGroup(furigana) {
            if (!furigana) return '‰ªñ';
            const firstChar = furigana.charAt(0);
            const code = firstChar.charCodeAt(0);

            // „Å≤„Çâ„Åå„Å™/„Ç´„Çø„Ç´„Éä ÁØÑÂõ≤Âà§ÂÆö
            if ((code >= 0x3041 && code <= 0x3096) || (code >= 0x30A1 && code <= 0x30FA)) {
                const char = firstChar.replace(/[„Ç°-„É∂]/g, s => String.fromCharCode(s.charCodeAt(0) - 0x60)); // „Ç´„Çø„Ç´„Éä„Çí„Å≤„Çâ„Åå„Å™„Å´
                if ('„ÅÇ„ÅÑ„ÅÜ„Åà„Åä'.includes(char)) return '„ÅÇË°å';
                if ('„Åã„Åç„Åè„Åë„Åì„Åå„Åé„Åê„Åí„Åî'.includes(char)) return '„ÅãË°å';
                if ('„Åï„Åó„Åô„Åõ„Åù„Åñ„Åò„Åö„Åú„Åû'.includes(char)) return '„ÅïË°å';
                if ('„Åü„Å°„Å§„Å¶„Å®„Å†„Å¢„Å•„Åß„Å©'.includes(char)) return '„ÅüË°å';
                if ('„Å™„Å´„Å¨„Å≠„ÅÆ'.includes(char)) return '„Å™Ë°å';
                if ('„ÅØ„Å≤„Åµ„Å∏„Åª„Å∞„Å≥„Å∂„Åπ„Åº„Å±„Å¥„Å∑„Å∫„ÅΩ'.includes(char)) return '„ÅØË°å';
                if ('„Åæ„Åø„ÇÄ„ÇÅ„ÇÇ'.includes(char)) return '„ÅæË°å';
                if ('„ÇÑ„ÇÜ„Çà'.includes(char)) return '„ÇÑË°å';
                if ('„Çâ„Çä„Çã„Çå„Çç'.includes(char)) return '„ÇâË°å';
                if ('„Çè„Çí„Çì'.includes(char)) return '„ÇèË°å';
            }
            if (/[a-zA-Z]/.test(firstChar)) return firstChar.toUpperCase();
            return '‰ªñ';
        }

        function processData() {
            const text = document.getElementById('indexDATABASE').value.trim();
            if (!text) {
                rawRecords = [];
                headerConfigs = [];
                ageShowFlags = {};
                updateStats();
                renderView();
                return;
            }

            const allParsed = text.split('\n')
                .filter(l => l.trim() !== '' && !l.trim().startsWith('#'))
                .map(line => {
                    // Split by comma only
                    const cols = line.split(',').map(s => s.trim().replace(/^"|"$/g, ''));
                    const itemName = cols[2] || '';
                    const dateInfo = parseDate(cols[0]);

                    return {
                        dateStr: dateInfo.str,
                        ts: dateInfo.ts,
                        valid: dateInfo.valid,
                        name: cols[1] || '',
                        item: itemName,
                        content: cols[3] || ''
                    };
                })
                .filter(r => r.name && r.item && r.name !== 'ÂêçÂâç'); // Allow invalid dates (ts=0), but filter empty names/items and header

            // Debug: found invalid date records
            const invalidDateRecords = allParsed.filter(r => !r.valid && r.name && r.item && r.name !== 'ÂêçÂâç');
            if (invalidDateRecords.length > 0) {
                console.log('[ProcessData] Included records with invalid dates:', invalidDateRecords);
            }

            allParsed.sort((a, b) => b.ts - a.ts);

            const isFinalOnly = document.getElementById('enableDedup').checked;
            const allItems = new Set();

            if (isFinalOnly) {
                const seen = new Map();
                rawRecords = [];

                allParsed.forEach(r => {
                    const key = `${r.name}|${r.item}`;
                    if (!seen.has(key)) {
                        seen.set(key, r);
                        rawRecords.push(r);
                    }
                    allItems.add(r.item);
                });
            } else {
                rawRecords = allParsed;
                allParsed.forEach(r => allItems.add(r.item));
            }

            // Sync headerConfigs with current data while preserving settings
            const configMap = new Map();
            headerConfigs.forEach(c => configMap.set(c.raw, c));

            // Initial load from storage if needed
            if (headerConfigs.length === 0) {
                const saved = loadColumnOrder();
                if (saved && Array.isArray(saved) && saved.length > 0) {
                    // Check if old format (string array) or new format (object array)
                    if (typeof saved[0] === 'string') {
                        saved.forEach(s => {
                            configMap.set(s, {
                                raw: s,
                                alias: s,
                                active: true,
                                showAge: isBirthdateField(s),
                                ageAlias: 'Âπ¥ÈΩ¢'
                            });
                        });
                    } else {
                        saved.forEach(c => {
                            // Force enable showAge for birthdate fields if it's undefined (legacy save)
                            if (isBirthdateField(c.raw) && (c.showAge === undefined || c.showAge === null)) {
                                c.showAge = true;
                            }
                            if (isBirthdateField(c.raw) && !c.ageAlias) {
                                c.ageAlias = 'Âπ¥ÈΩ¢';
                            }
                            configMap.set(c.raw, c);
                        });
                    }
                }
            }

            // Rebuild headerConfigs
            // 1. Keep existing/saved order for items that still exist
            const newOrder = [];
            const processed = new Set();

            // Use current configs or saved order as the base for ordering
            const sourceList = headerConfigs.length > 0 ? headerConfigs : (loadColumnOrder() || []);

            // Handle sourceList being strings (old save) or objects
            sourceList.forEach(item => {
                const raw = (typeof item === 'string') ? item : item.raw;
                if (allItems.has(raw) && !processed.has(raw)) {
                    let conf = configMap.get(raw);
                    if (!conf) {
                        conf = { raw: raw, alias: raw, active: true, showAge: isBirthdateField(raw), ageAlias: 'Âπ¥ÈΩ¢' };
                    }
                    newOrder.push(conf);
                    processed.add(raw);
                }
            });

            // 2. Append new items (alphabetical)
            const remaining = Array.from(allItems).filter(x => !processed.has(x)).sort();
            remaining.forEach(r => {
                const conf = configMap.get(r) || { raw: r, alias: r, active: true, showAge: isBirthdateField(r), ageAlias: 'Âπ¥ÈΩ¢' };
                newOrder.push(conf);
            });

            headerConfigs = newOrder;

            currentIndex = 0;
            updateStats();
            renderHeaderSettings();
            renderView();

            // Debounce save to IndexedDB
            if (window.saveTimeout) clearTimeout(window.saveTimeout);
            window.saveTimeout = setTimeout(() => {
                saveDataToDB(text);
            }, 500);
        }

        // ===== IndexedDB Persistence =====
        const DB_NAME = 'DataViewerDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'settings';
        const DATA_KEY = 'csvData';

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
                request.onsuccess = (e) => resolve(e.target.result);
                request.onerror = (e) => reject(e);
            });
        }

        async function saveDataToDB(data) {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                store.put(data, DATA_KEY);
            } catch (e) {
                console.error('Failed to save data:', e);
            }
        }

        async function loadDataFromDB() {
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const request = store.get(DATA_KEY);

                request.onsuccess = () => {
                    if (request.result) {
                        document.getElementById('indexDATABASE').value = request.result;
                        processData();
                    }
                };
            } catch (e) {
                console.error('Failed to load data:', e);
            }
        }

        function updateStats() {
            const uniquePeople = new Set(rawRecords.map(r => r.name));
            const uniqueItems = new Set(rawRecords.map(r => r.item));

            document.getElementById('statsRecords').textContent = rawRecords.length;
            document.getElementById('statsPeople').textContent = uniquePeople.size;
            document.getElementById('statsItems').textContent = uniqueItems.size;
        }

        function renderHeaderSettings() {
            const container = document.getElementById('headerSettings');

            if (headerConfigs.length === 0) {
                container.innerHTML = '<p style="color: #94a3b8; font-size: 0.85rem;">„Åæ„Åö„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Çì„Åß„Åè„Å†„Åï„ÅÑ</p>';
                return;
            }

            container.innerHTML = headerConfigs.map((config, i) => {
                const handleChange = `headerConfigs[${i}].active = this.checked; renderView(); saveColumnOrder();`;
                const handleAlias = `headerConfigs[${i}].alias = this.value; renderView(); saveColumnOrder();`;
                const handleAgeAlias = `headerConfigs[${i}].ageAlias = this.value; renderView(); saveColumnOrder();`;

                let inner = `
            <div class="header-setting-item">
                <div style="cursor:grab; color:#ccc; margin-right:4px;" title="„Éâ„É©„ÉÉ„Ç∞„Åß‰∏¶„Å≥Êõø„Åà">‚ãÆ‚ãÆ</div>
                <input type="checkbox" ${config.active ? 'checked' : ''} onchange="${handleChange}">
                <input type="text" value="${escapeHtml(config.alias)}" oninput="${handleAlias}">
            </div>
        `;
                if (isBirthdateField(config.raw)) {
                    const isChecked = config.showAge ? 'checked' : '';
                    inner = `
                <div class="birthdate-group">
                    <div class="header-setting-item">
                        <div style="cursor:grab; color:#ccc; margin-right:4px;" title="„Éâ„É©„ÉÉ„Ç∞„Åß‰∏¶„Å≥Êõø„Åà">‚ãÆ‚ãÆ</div>
                        <input type="checkbox" ${config.active ? 'checked' : ''} onchange="${handleChange}">
                        <input type="text" value="${escapeHtml(config.alias)}" oninput="${handleAlias}">
                    </div>
                    <div class="age-checkbox">
                        <input type="checkbox" ${isChecked} onchange="toggleAgeDisplay(${i})">
                        <input type="text" value="${escapeHtml(config.ageAlias || 'Âπ¥ÈΩ¢')}" oninput="${handleAgeAlias}">
                    </div>
                </div>
            `;
                }
                return inner;
            }).join('');

            // Re-bind drag events for settings list if we want to sort there too (Optional, but user said "reorder settings").
            // The user said "remember check and order". 
            // The current drag-drop is on the CARD fields. 
            // The previous implementation had drag-drop on cards affecting headerConfigs.
            // Let's ensure the settings list also reflects this or allows it. 
            // For now, the card view drag-drop controls the order.
        }

        function toggleAgeDisplay(index) {
            headerConfigs[index].showAge = !headerConfigs[index].showAge;
            renderView();
            saveColumnOrder();
        }

        function getFilteredPeople() {
            const searchTerm = document.getElementById('globalSearch').value.toLowerCase();
            // Note: dateFilter is now used for age calculation, not filtering.

            const grouped = {};
            rawRecords.forEach(record => {
                if (!grouped[record.name]) {
                    grouped[record.name] = {
                        name: record.name,
                        records: {},
                        maxTs: 0
                    };
                }

                const key = record.item;
                const currentRecord = grouped[record.name].records[key];

                // Logic to determine if we should update the record for this item
                let shouldUpdate = false;

                if (!currentRecord) {
                    shouldUpdate = true;
                } else {
                    const isNewer = record.ts > currentRecord.ts;
                    const hasContent = record.content && record.content.trim() !== '';
                    const currentHasContent = currentRecord.content && currentRecord.content.trim() !== '';

                    const isBirth = isBirthdateField(key);

                    if (isBirth) {
                        const newVal = (record.content && record.content.trim() !== '') ? record.content : record.dateStr;
                        const currVal = (currentRecord.content && currentRecord.content.trim() !== '') ? currentRecord.content : currentRecord.dateStr;

                        const newBdayTs = parseDate(newVal).ts;
                        const currBdayTs = parseDate(currVal).ts;

                        if (newBdayTs < currBdayTs) {
                            shouldUpdate = true;
                        } else if (newBdayTs === currBdayTs) {
                            if (hasContent && !currentHasContent) {
                                shouldUpdate = true;
                            } else if (isNewer && (hasContent === currentHasContent)) {
                                shouldUpdate = true;
                            }
                        }
                    } else if (hasContent) {
                        if (isNewer || !currentHasContent) {
                            shouldUpdate = true;
                        }
                    } else {
                        if (!currentHasContent && isNewer) {
                            shouldUpdate = true;
                        }
                    }
                }

                if (shouldUpdate) {
                    grouped[record.name].records[key] = record;
                }

                if (record.ts > grouped[record.name].maxTs) {
                    grouped[record.name].maxTs = record.ts;
                }
            });

            const list = Object.values(grouped)
                .filter(person => {
                    const matchesSearch = person.name.toLowerCase().includes(searchTerm);
                    return matchesSearch; // Date filter removed
                });

            list.sort((a, b) => {
                const fA = getFurigana(a);
                const fB = getFurigana(b);
                return fA.localeCompare(fB, 'ja');
            });

            return list;
        }

        // ===== Rendering =====
        function renderView() {
            filteredPeople = getFilteredPeople();
            const container = document.getElementById('cardView');
            const pageInfo = document.getElementById('pageInfo');

            if (filteredPeople.length === 0) {
                container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üîç</div>
                <p>Êù°‰ª∂„Å´ÂêàËá¥„Åô„Çã„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>
            </div>
        `;
                pageInfo.textContent = '0 / 0';
                return;
            }

            if (currentIndex >= filteredPeople.length) {
                currentIndex = 0;
            }

            const person = filteredPeople[currentIndex];
            renderCard(person, container);
            pageInfo.textContent = `${currentIndex + 1} / ${filteredPeople.length}`;
            renderNameSidebar();
        }

        function toggleRightSidebar() {
            document.getElementById('right-sidebar').classList.toggle('open');
        }

        function jumpToPerson(index) {
            currentIndex = index;
            renderView();
            // Close sidebar on small screens if jumping
            if (window.innerWidth <= 1024) {
                document.getElementById('right-sidebar').classList.remove('open');
            }
        }

        function renderNameSidebar() {
            const container = document.getElementById('nameListContainer');
            if (filteredPeople.length === 0) {
                container.innerHTML = '<p style="font-size:0.8rem; color:#94a3b8;">„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>';
                return;
            }

            // Grouping
            const groups = {};
            filteredPeople.forEach((person, index) => {
                const furigana = getFurigana(person);
                const groupName = getFuriganaGroup(furigana);
                if (!groups[groupName]) groups[groupName] = [];
                groups[groupName].push({ person, index, furigana });
            });

            const sortedGroups = Object.keys(groups).sort((a, b) => {
                const order = ['„ÅÇË°å', '„ÅãË°å', '„ÅïË°å', '„ÅüË°å', '„Å™Ë°å', '„ÅØË°å', '„ÅæË°å', '„ÇÑË°å', '„ÇâË°å', '„ÇèË°å', '‰ªñ'];
                const idxA = order.indexOf(a);
                const idxB = order.indexOf(b);
                if (idxA !== -1 && idxB !== -1) return idxA - idxB;
                if (idxA !== -1) return -1;
                if (idxB !== -1) return 1;
                return a.localeCompare(b);
            });

            container.innerHTML = sortedGroups.map(groupName => `
                <div class="name-list-group">
                    <div class="name-list-header">${groupName}</div>
                    ${groups[groupName].map(item => {
                const isActive = (item.index === currentIndex) ? 'active' : '';
                const fHint = item.furigana !== item.person.name ? `<span class="furigana-hint">(${escapeHtml(item.furigana)})</span>` : '';
                return `<div class="name-item ${isActive}" onclick="jumpToPerson(${item.index})">
                            ${escapeHtml(item.person.name)}${fHint}
                        </div>`;
            }).join('')}
                </div>
            `).join('');
        }

        function renderCard(person, container) {
            const activeWithIndex = headerConfigs
                .map((config, idx) => ({ config, headerIndex: idx }))
                .filter(({ config }) => config.active);

            const fieldsHtml = activeWithIndex.map(({ config, headerIndex }) => {
                const record = person.records[config.raw];
                const displayValue = record ? record.content : '-';
                const displayDate = record ? record.dateStr : 'N/A';
                let ageHtml = '';

                const isBirth = isBirthdateField(config.raw);

                if (config.showAge && isBirth && record) {
                    const birthValue = (record.content && record.content.trim() !== '') ? record.content : record.dateStr;
                    const refDate = document.getElementById('dateFilter').value;
                    const age = calculateAge(birthValue, refDate);
                    const ageAlias = config.ageAlias || 'Âπ¥ÈΩ¢';
                    if (age !== null) ageHtml = `<div class="field-age">${escapeHtml(ageAlias)}: ${age}Êâç</div>`;
                }
                return `            <div class="card-field" draggable="true" data-header-index="${headerIndex}" title="„Éâ„É©„ÉÉ„Ç∞„Åß‰∏¶„Å≥Êõø„Åà">
                <div class="card-field-handle">‚ãÆ‚ãÆ</div>
                <div class="field-label">${escapeHtml(config.alias)}</div>
                <div class="field-value">
                    ${escapeHtml(displayValue)}
                    ${ageHtml}
                </div>
                <div class="field-date">üìÖ ${escapeHtml(displayDate)}</div>
            </div>
        `;
            }).join('');

            const emptyMessage = activeWithIndex.length === 0
                ? '<div class="empty-state"><p>Ë°®Á§∫„Åô„ÇãÈ†ÖÁõÆ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p></div>'
                : '';

            container.innerHTML = `
        <div class="db-card">
            <div class="card-header">
                <div style="font-size:0.9rem; color:var(--primary); font-weight:800;">PRIMARY KEY</div>
                <h1>${escapeHtml(person.name)}</h1>
            </div>
            <div class="card-body">
                ${fieldsHtml || emptyMessage}
            </div>
        </div>
    `;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function changePage(step) {
            if (filteredPeople.length === 0) return;

            currentIndex = (currentIndex + step + filteredPeople.length) % filteredPeople.length;
            renderView();
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') changePage(-1);
            if (e.key === 'ArrowRight') changePage(1);
        });

        function setupDragDrop() {
            const el = document.getElementById('cardView');
            if (!el) return;
            el.addEventListener('dragstart', e => {
                const field = e.target.closest('.card-field');
                if (!field) return;
                draggedIndex = parseInt(field.getAttribute('data-header-index'), 10);
                field.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', String(draggedIndex));
            });
            el.addEventListener('dragend', e => {
                const field = e.target.closest('.card-field');
                if (field) field.classList.remove('dragging');
                draggedIndex = null;
            });
            el.addEventListener('dragover', e => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });
            el.addEventListener('drop', e => {
                e.preventDefault();
                const field = e.target.closest('.card-field');
                if (!field || draggedIndex === null) return;
                let toIndex = parseInt(field.getAttribute('data-header-index'), 10);
                if (toIndex === draggedIndex) return;
                const moved = headerConfigs.splice(draggedIndex, 1)[0];
                if (draggedIndex < toIndex) toIndex--;
                headerConfigs.splice(toIndex, 0, moved);
                saveColumnOrder();
                renderHeaderSettings();
                renderView();
            });
        }

        window.addEventListener('load', () => {
            // Set default date filter to today
            const today = new Date();
            const yyyy = today.getFullYear();
            const mm = String(today.getMonth() + 1).padStart(2, '0');
            const dd = String(today.getDate()).padStart(2, '0');
            document.getElementById('dateFilter').value = `${yyyy}-${mm}-${dd}`;

            updateStats();
            renderHeaderSettings();
            renderView();
            setupDragDrop();
            if (loadColumnOrder()) document.getElementById('btnResetOrder').style.display = '';

            // Load persisted data
            loadDataFromDB();
        });

        async function clearData() {
            if (!confirm('„Éá„Éº„Çø„ÇíÂÖ®„Å¶ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) return;
            document.getElementById('indexDATABASE').value = '';
            processData(); // This will reset internal state and view

            // Clear IndexedDB
            try {
                const db = await openDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                store.delete(DATA_KEY);
                
                // Complete the transaction before reload
                await new Promise((resolve, reject) => {
                    tx.oncomplete = resolve;
                    tx.onerror = reject;
                });
                
                // Reload the page to ensure clean state
                location.reload();
            } catch (e) {
                console.error('Failed to clear data:', e);
                alert('„Éá„Éº„Çø„ÅÆ„ÇØ„É™„Ç¢„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Éö„Éº„Ç∏„ÇíÊâãÂãï„ÅßÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            }
        }
    </script>

</body>

</html>