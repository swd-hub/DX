<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°±è¾²æ”¯æ´ã‚¿ã‚¤ãƒ ãƒ†ãƒ¼ãƒ–ãƒ«</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Meirio, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 100%;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #2d3748;
            margin-bottom: 30px;
            font-size: 28px;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            background: linear-gradient(135deg, #f6f8fb 0%, #e9ecef 100%);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .controls h2 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .controls h2::before {
            content: "âš™ï¸";
            font-size: 20px;
        }

        .field-selector {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 15px;
            background: white;
            border-radius: 10px;
            transition: all 0.3s ease;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .checkbox-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
            border-color: #667eea;
        }

        .checkbox-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .checkbox-item label {
            cursor: pointer;
            color: #2d3748;
            font-weight: 500;
            flex: 1;
        }

        .data-input {
            margin-bottom: 20px;
        }

        .data-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .data-header h3 {
            color: #2d3748;
            margin: 0;
            font-size: 16px;
        }

        .btn-small-clear {
            padding: 5px 15px;
            font-size: 13px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(245, 87, 108, 0.2);
        }

        .btn-small-clear:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(245, 87, 108, 0.3);
        }

        textarea {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-family: 'Consolas', monospace;
            font-size: 13px;
            resize: vertical;
            transition: all 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.4);
        }

        .timeline-container {
            overflow-x: auto;
            margin-top: 5px;
            border-radius: 0 0 15px 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .top-scroll-container {
            overflow-x: auto;
            overflow-y: hidden;
            height: 20px;
            margin-top: 30px;
            border-radius: 15px 15px 0 0;
            background: #f7fafc;
        }

        .top-scroll-dummy {
            height: 1px;
        }

        .timeline-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            background: white;
            min-width: 800px;
        }

        .timeline-table th,
        .timeline-table td {
            padding: 10px;
            text-align: left;
            border: 1px solid #e2e8f0;
            vertical-align: top;
        }

        .timeline-table thead th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .timeline-table thead th:first-child {
            border-top-left-radius: 15px;
        }

        .timeline-table thead th:last-child {
            border-top-right-radius: 15px;
        }

        .timeline-table tbody tr {
            transition: all 0.3s ease;
        }

        .timeline-table tbody tr:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
        }

        .name-cell {
            font-weight: 600;
            color: #2d3748;
            background: #f7fafc;
            position: sticky;
            left: 0;
            z-index: 5;
        }

        .timeline-cell {
            min-width: 120px;
            font-size: 12px;
            color: #4a5568;
            vertical-align: top;
        }

        .cell-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .field-item {
            padding: 2px 6px;
            background: linear-gradient(135deg, #f6f8fb 0%, #e9ecef 100%);
            border-radius: 5px;
            border-left: 3px solid #667eea;
        }

        .field-label {
            font-weight: 600;
            color: #667eea;
            font-size: 10px;
            margin-bottom: 2px;
        }

        .field-value {
            color: #2d3748;
        }

        .no-data {
            text-align: center;
            padding: 40px;
            color: #a0aec0;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 22px;
            }

            .field-selector {
                grid-template-columns: 1fr;
            }

            .button-group {
                flex-direction: column;
            }

            button {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸŒ¾ å°±è¾²æ”¯æ´ã‚¿ã‚¤ãƒ ãƒ†ãƒ¼ãƒ–ãƒ«</h1>

        <div class="controls">
            <div class="data-input">
                <div class="data-header">
                    <h3>ğŸ’¾ indexDATABASE / ğŸ“‹ ãƒ‡ãƒ¼ã‚¿å…¥åŠ›</h3>
                    <button class="btn-small-clear" onclick="clearData()">ğŸ§¹ ã‚¯ãƒªã‚¢</button>
                </div>
                <input type="file" id="fileInput" accept=".csv,.json,.txt" style="display: none;" />
                <textarea id="dataInput"
                    placeholder="ã€æ—¥ä»˜ã€åå‰ã€ä½œæ¥­é …ç›®ã€(ä»»æ„ã§å€¤)ã€‘ã®é †ã«å…¥åŠ›ã—ã¦ãã ã•ã„&#10;ä¾‹ï¼š&#10;R6.4, ç”°ä¸­, è€•èµ·&#10;R6.4, ç”°ä¸­, è‚¥æ–™, 10kg&#10;R6.5, ä½è—¤, æ°´ã‚„ã‚Š&#10;&#10;ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿"></textarea>
            </div>

            <h2>è¡¨ç¤ºé …ç›®è¨­å®šï¼ˆãƒ‡ãƒ¼ã‚¿å†…ã®é …ç›®ã‚’è‡ªå‹•æ¤œå‡ºï¼‰</h2>
            <div class="field-selector" id="fieldSelector"></div>

            <div
                style="margin-top: 15px; padding: 15px; background: rgba(255, 255, 255, 0.7); border-radius: 10px; border: 1px solid #e2e8f0; font-size: 0.9rem; color: #4a5568;">
                <div style="font-weight: bold; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
                    ğŸ” è¡¨ç¤ºåˆ¤å®šã®åŸºæº–
                </div>
                <div style="display: flex; flex-wrap: wrap; gap: 20px; align-items: center;">
                    <div>
                        åŸºæº–æ—¥: <input type="date" id="referenceDate" onchange="generateTimeline(true)"
                            style="padding: 5px; border: 1px solid #cbd5e1; border-radius: 4px;">
                        <button type="button" class="btn-small-clear" onclick="setToToday()"
                            style="background: #667eea; margin-left: 5px;">ä»Šæ—¥</button>
                    </div>
                    <div>
                        æ–°è¦å°±è¾²æ—¥ãŒãªã„å ´åˆã®é¡ã‚Šå¹´æ•°(X): <input type="number" id="backwardYearsX" value="4" min="1"
                            onchange="generateTimeline(true)"
                            style="padding: 5px; width: 60px; border: 1px solid #cbd5e1; border-radius: 4px;"> å¹´
                    </div>
                </div>
                <div style="margin-top: 10px; font-size: 0.8rem; line-height: 1.5; color: #718096;">
                    â€»ã€Œé’å¹´ç­‰å°±è¾²è¨ˆç”»æ¨é€²ä¼šè­°ã€ã®ã€Œæ–°è¦å°±è¾²ã€ãŒã‚ã‚‹å ´åˆã¯èªå®šæ—¥ãŒåŸºæº–æ—¥ã‚ˆã‚Š5å¹´ä»¥å†…ã€<br>
                    ã€€ç„¡ã„å ´åˆã¯æœ€ã‚‚æ–°ã—ã„è¨˜éŒ²ãŒåŸºæº–æ—¥ã‚ˆã‚ŠXå¹´ä»¥å†…ã®å¯¾è±¡è€…ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
                </div>
            </div>

            <div style="margin-top: 15px; display: flex; justify-content: flex-end;">
                <button class="btn-primary" onclick="copyTableAsCSV(this)"
                    style="background: #48bb78; width: auto; padding: 8px 16px; font-size: 13px;">ğŸ“‹
                    ç”Ÿæˆã•ã‚ŒãŸè¡¨ã‚’CSVã‚³ãƒ”ãƒ¼</button>
            </div>
        </div>

        <div class="button-group" style="display: none;">
            <button class="btn-primary" onclick="generateTimeline()">ğŸ“Š ã‚¿ã‚¤ãƒ ãƒ†ãƒ¼ãƒ–ãƒ«ç”Ÿæˆ</button>
        </div>

        <div class="top-scroll-container" id="topScrollContainer">
            <div class="top-scroll-dummy" id="topScrollDummy"></div>
        </div>

        <div class="timeline-container">
            <table class="timeline-table" id="timelineTable">
                <thead>
                    <tr id="tableHeader"></tr>
                </thead>
                <tbody id="tableBody">
                    <tr>
                        <td colspan="100" class="no-data">ä¸Šã«ãƒ‡ãƒ¼ã‚¿ã‚’å…¥åŠ›ã™ã‚‹ã¨ã€è‡ªå‹•çš„ã«ã‚¿ã‚¤ãƒ ãƒ†ãƒ¼ãƒ–ãƒ«ãŒç”Ÿæˆã•ã‚Œã¾ã™</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        let availableFields = [];
        let parsedData = [];
        let nameFieldKey = null;
        let selectedFieldStates = {};
        let isInitialLoading = true; // Guard to prevent auto-save during loading

        // IndexedDB Configuration
        const DB_NAME = 'DataViewerDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'settings';
        const DATA_KEY = 'csvData';
        const SETTINGS_KEY = 'fieldSettings';

        let dbInstance = null;
        function getDB() {
            if (dbInstance) return Promise.resolve(dbInstance);
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
                request.onsuccess = (e) => {
                    dbInstance = e.target.result;
                    resolve(dbInstance);
                };
                request.onerror = (e) => reject(e);
            });
        }

        // Debounced Save
        let saveTimeout = null;
        async function saveDataToDB(data) {
            if (isInitialLoading) return; // CRITICAL: Stop auto-save during startup
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(async () => {
                try {
                    const db = await getDB();
                    const tx = db.transaction(STORE_NAME, 'readwrite');
                    tx.objectStore(STORE_NAME).put(data, DATA_KEY);
                } catch (e) {
                    console.error('Failed to save data:', e);
                }
            }, 1000);
        }

        async function saveSettingsToDB(settings) {
            if (isInitialLoading) return;
            try {
                const db = await getDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                tx.objectStore(STORE_NAME).put(settings, SETTINGS_KEY);
            } catch (e) {
                console.error('Failed to save settings:', e);
            }
        }

        async function loadDataFromDB() {
            try {
                const db = await getDB();
                const tx = db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);

                const dataReq = store.get(DATA_KEY);
                dataReq.onsuccess = () => {
                    if (dataReq.result) {
                        document.getElementById('dataInput').value = dataReq.result;

                        const settingsReq = store.get(SETTINGS_KEY);
                        settingsReq.onsuccess = () => {
                            if (settingsReq.result) {
                                selectedFieldStates = settingsReq.result;
                                if (selectedFieldStates._referenceDate) {
                                    document.getElementById('referenceDate').value = selectedFieldStates._referenceDate;
                                } else {
                                    setToToday();
                                }
                                if (selectedFieldStates._backwardYearsX) {
                                    document.getElementById('backwardYearsX').value = selectedFieldStates._backwardYearsX;
                                }
                            } else {
                                setToToday();
                            }
                            isInitialLoading = false;
                            generateTimeline();
                        };
                        settingsReq.onerror = () => {
                            setToToday();
                            isInitialLoading = false;
                            generateTimeline();
                        };
                    } else {
                        setToToday();
                        isInitialLoading = false;
                    }
                };
                dataReq.onerror = () => { isInitialLoading = false; };
            } catch (e) {
                console.error('Failed to load data:', e);
                isInitialLoading = false;
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') inQuotes = !inQuotes;
                else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else current += char;
            }
            result.push(current.trim());
            return result;
        }

        function parseJapaneseDate(text) {
            if (!text) return null;
            // Match Sxx.m, Hxx.m, Rxx.m or yyyy.m with common separators
            const match = text.match(/([SRH]?)(\d+)[å¹´./-]?(\d+)/);
            if (!match) return null;

            const era = match[1];
            const yearNum = parseInt(match[2]);
            const month = parseInt(match[3]);
            if (month < 1 || month > 12) return null;

            let christianYear = yearNum;
            if (era === 'R') christianYear = 2018 + yearNum;
            else if (era === 'H') christianYear = 1988 + yearNum;
            else if (era === 'S') christianYear = 1925 + yearNum;

            return { year: christianYear, month, label: toEraLabel(christianYear, month) };
        }

        function toEraLabel(year, month) {
            if (year > 2019 || (year === 2019 && month >= 5)) return `R${year - 2018}.${month}`;
            if (year > 1989 || (year === 1989 && month >= 1)) return `H${year - 1988}.${month}`;
            if (year > 1926 || (year === 1926 && month >= 12)) return `S${year - 1925}.${month}`;
            return `${year}.${month}`;
        }

        function getTotalMonths(dateObj) {
            return dateObj.year * 12 + (dateObj.month - 1);
        }

        function fromTotalMonths(total) {
            const year = Math.floor(total / 12);
            const month = (total % 12) + 1;
            return { year, month, label: toEraLabel(year, month) };
        }

        function parseInputData(input) {
            const lines = input.trim().split('\n').filter(line => line.trim());
            if (lines.length === 0) return [];
            let eavCount = 0;
            let sampleLines = lines.filter(l => l.includes(','));
            let sampleSize = Math.min(sampleLines.length, 5);
            for (let i = 0; i < sampleSize; i++) {
                const parts = parseCSVLine(sampleLines[i]);
                if (parts.length >= 2 && parseJapaneseDate(parts[0])) eavCount++;
            }
            console.log('Detected format:', eavCount > 0 ? 'EAV' : 'WIDE', { eavCount });
            if (eavCount > 0) {
                const peopleMap = new Map();
                lines.forEach(line => {
                    const row = parseCSVLine(line);
                    if (row.length < 2) return;
                    const dateParsed = parseJapaneseDate(row[0]);
                    if (!dateParsed) return;
                    const name = row[1], attr = (row[2] || "æœªåˆ†é¡").trim();
                    let val = (row[3] || "").trim();
                    if (val === "") val = attr;
                    if (!peopleMap.has(name)) peopleMap.set(name, { name, events: [] });
                    peopleMap.get(name).events.push({ date: row[0], attr, val });
                });
                return Array.from(peopleMap.values()).map(p => ({ _type: 'EAV', name: p.name, events: p.events }));
            } else {
                const headers = parseCSVLine(lines[0]);
                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const values = parseCSVLine(lines[i]), obj = { _type: 'WIDE' };
                    headers.forEach((h, idx) => { if (h) obj[h] = values[idx] || ''; });
                    data.push(obj);
                }
                return data;
            }
        }

        function findNameField(data) {
            if (data.length === 0) return null;
            const keys = Object.keys(data[0]);
            return keys.find(k => k.includes('åå‰') || k.toLowerCase().includes('name')) || keys[0];
        }

        function generateAvailableFields(data) {
            if (data.length === 0) return [];
            const allKeys = new Set();
            if (data[0]._type === 'EAV') {
                nameFieldKey = 'name';
                data.forEach(r => r.events.forEach(e => { if (e.attr) allKeys.add(e.attr.trim()); }));
            } else {
                nameFieldKey = findNameField(data);
                data.forEach(r => Object.keys(r).forEach(k => {
                    if (k !== nameFieldKey && k !== '_type' && k.trim() && k.trim() !== 'undefined') allKeys.add(k.trim());
                }));
            }
            const fields = Array.from(allKeys).sort().map(key => ({
                key, label: key, default: selectedFieldStates[key] !== undefined ? selectedFieldStates[key] : true
            }));
            console.log('Available fields:', fields.map(f => f.key));
            return fields;
        }

        function initFieldSelector() {
            const selector = document.getElementById('fieldSelector');
            selector.innerHTML = '';
            if (availableFields.length === 0) {
                selector.innerHTML = '<p style="color: #a0aec0; font-style: italic;">ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€ã¨é …ç›®ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</p>';
                return;
            }
            availableFields.forEach(field => {
                const div = document.createElement('div');
                div.className = 'checkbox-item';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `field_${field.key}`;
                checkbox.checked = field.default;
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = field.label;
                div.appendChild(checkbox);
                div.appendChild(label);
                selector.appendChild(div);

                checkbox.addEventListener('change', () => {
                    console.log(`Field ${field.key} changed to ${checkbox.checked}`);
                    selectedFieldStates[field.key] = checkbox.checked;

                    // åŸºæº–æ—¥ã¨é¡ã‚Šå¹´æ•°ã‚‚ä¿å­˜å¯¾è±¡ã«å«ã‚ã‚‹
                    selectedFieldStates._referenceDate = document.getElementById('referenceDate').value;
                    selectedFieldStates._backwardYearsX = document.getElementById('backwardYearsX').value;

                    saveSettingsToDB(selectedFieldStates);
                    generateTimeline(true);
                });
            });
        }

        function extractTimePeriods(data) {
            const foundMonths = [];
            data.forEach(record => {
                let datesToParse = [];
                if (record._type === 'EAV') {
                    record.events.forEach(e => {
                        if (selectedFieldStates[e.attr.trim()] !== false) {
                            datesToParse.push(e.date);
                        }
                    });
                } else {
                    // Check values AND enabled headers for dates
                    Object.keys(record).forEach(k => {
                        if (k === nameFieldKey || k === '_type') return;
                        if (selectedFieldStates[k] === false) return;

                        const p = parseJapaneseDate(k);
                        if (p) foundMonths.push(p);

                        const v = record[k];
                        if (typeof v === 'string') {
                            const ms = v.match(/[SRH]?\d+[å¹´./-]\d+/g);
                            if (ms) datesToParse.push(...ms);
                        }
                    });
                }
                datesToParse.forEach(d => { const p = parseJapaneseDate(d); if (p) foundMonths.push(p); });
            });
            if (foundMonths.length === 0) return [];
            const indices = foundMonths.map(m => getTotalMonths(m));
            const min = Math.min(...indices), max = Math.max(...indices), periods = [];
            for (let m = min; m <= max; m++) periods.push(fromTotalMonths(m));
            return periods;
        }

        function generateTimeline(skipSelectorInit = false) {
            console.log('Generating timeline...', { skipSelectorInit });
            const input = document.getElementById('dataInput').value;
            if (!input.trim()) return;

            // Only save if it's not the initial DB load
            if (!isInitialLoading) saveDataToDB(input);

            parsedData = parseInputData(input);
            if (parsedData.length === 0) { return; }

            if (!skipSelectorInit) {
                availableFields = generateAvailableFields(parsedData);
                initFieldSelector();
            }
            renderTimelineOnly();
        }

        function renderTimelineOnly() {
            console.log('Rendering timeline with', parsedData.length, 'people');
            if (!parsedData || parsedData.length === 0) return;
            if (!selectedFieldStates) selectedFieldStates = {};

            const refDateStr = document.getElementById('referenceDate').value;
            const refDate = refDateStr ? new Date(refDateStr + 'T00:00:00') : new Date();
            const refTs = refDate.getTime();
            const yearsX = parseInt(document.getElementById('backwardYearsX').value) || 4;

            // åŸºæº–æ—¥ã‹ã‚‰Nå¹´å‰ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¨ˆç®—
            const getThresholdTs = (years) => {
                const d = new Date(refTs);
                d.setFullYear(d.getFullYear() - years);
                return d.getTime();
            };

            const fiveYearsTs = getThresholdTs(5);
            const xYearsTs = getThresholdTs(yearsX);

            // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            const filteredData = parsedData.filter(person => {
                let latestTs = 0;
                let shinukiShunoTs = null;

                if (person._type === 'EAV') {
                    person.events.forEach(ev => {
                        const parsed = parseJapaneseDate(ev.date);
                        if (!parsed) return;
                        const d = new Date(parsed.year, parsed.month - 1, 1);
                        const ts = d.getTime();
                        if (ts > latestTs) latestTs = ts;

                        if (ev.attr === 'é’å¹´ç­‰å°±è¾²è¨ˆç”»æ¨é€²ä¼šè­°' && ev.val === 'æ–°è¦å°±è¾²') {
                            if (shinukiShunoTs === null || ts > shinukiShunoTs) {
                                shinukiShunoTs = ts;
                            }
                        }
                    });
                } else {
                    // WIDEå½¢å¼
                    Object.keys(person).forEach(k => {
                        if (k === nameFieldKey || k === '_type') return;
                        const val = person[k];
                        if (!val || val === '-') return;

                        const dk = parseJapaneseDate(k); // ã‚«ãƒ©ãƒ åãŒæ—¥ä»˜ã®å ´åˆ
                        if (dk) {
                            const ts = new Date(dk.year, dk.month - 1, 1).getTime();
                            if (ts > latestTs) latestTs = ts;
                            // WIDEå½¢å¼ã§ç‰¹å®šã®ã‚»ãƒ«ãŒã€Œæ–°è¦å°±è¾²ã€ã‚’æŒ‡ã™å ´åˆï¼ˆé …ç›®åãŒã€Œé’å¹´ç­‰å°±è¾²è¨ˆç”»æ¨é€²ä¼šè­°ã€ã‹ã¤å€¤ãŒã€Œæ–°è¦å°±è¾²ã€ï¼‰
                            if (k === 'é’å¹´ç­‰å°±è¾²è¨ˆç”»æ¨é€²ä¼šè­°' && val === 'æ–°è¦å°±è¾²') {
                                if (shinukiShunoTs === null || ts > shinukiShunoTs) shinukiShunoTs = ts;
                            }
                        }

                        // å€¤ã®ä¸­ã«æ—¥ä»˜ãŒå«ã¾ã‚Œã‚‹å ´åˆ
                        if (typeof val === 'string') {
                            const dates = val.match(/[SRH]?\d+[å¹´./-]\d+/g);
                            if (dates) {
                                dates.forEach(dstr => {
                                    const parsed = parseJapaneseDate(dstr);
                                    if (parsed) {
                                        const ts = new Date(parsed.year, parsed.month - 1, 1).getTime();
                                        if (ts > latestTs) latestTs = ts;
                                        if (k === 'é’å¹´ç­‰å°±è¾²è¨ˆç”»æ¨é€²ä¼šè­°' && val.includes('æ–°è¦å°±è¾²')) {
                                            if (shinukiShunoTs === null || ts > shinukiShunoTs) shinukiShunoTs = ts;
                                        }
                                    }
                                });
                            }
                        }
                    });
                }

                if (shinukiShunoTs !== null) {
                    // ã‚±ãƒ¼ã‚¹1: æ–°è¦å°±è¾²ãŒã‚ã‚‹å ´åˆã€5å¹´ä»¥å†…
                    return shinukiShunoTs >= fiveYearsTs && shinukiShunoTs <= refTs;
                } else {
                    // ã‚±ãƒ¼ã‚¹2: æ–°è¦å°±è¾²ãŒãªã„å ´åˆã€æœ€æ–°è¨˜éŒ²ãŒXå¹´ä»¥å†…
                    return latestTs >= xYearsTs && latestTs <= refTs;
                }
            });

            console.log('Filtered data size:', filteredData.length);

            try {
                const periods = extractTimePeriods(filteredData);
                const headerRow = document.getElementById('tableHeader');
                headerRow.innerHTML = '<th class="name-cell">åå‰</th>';
                periods.forEach(p => { const th = document.createElement('th'); th.textContent = p.label; headerRow.appendChild(th); });

                const tbody = document.getElementById('tableBody');
                tbody.innerHTML = '';

                if (filteredData.length === 0) {
                    tbody.innerHTML = `<tr><td colspan="100" class="no-data">è¡¨ç¤ºåŸºæº–ã«ä¸€è‡´ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</td></tr>`;
                    return;
                }

                filteredData.forEach(person => {
                    const row = document.createElement('tr');
                    const nameCell = document.createElement('td');
                    nameCell.className = 'name-cell';
                    nameCell.textContent = person[nameFieldKey] || 'ä¸æ˜';
                    row.appendChild(nameCell);
                    periods.forEach(p => {
                        const cell = document.createElement('td');
                        cell.className = 'timeline-cell';
                        const contentDiv = document.createElement('div');
                        contentDiv.className = 'cell-content';
                        let hasContent = false;
                        if (person._type === 'EAV') {
                            person.events.filter(ev => {
                                const parsed = parseJapaneseDate(ev.date);
                                return parsed && parsed.label === p.label;
                            }).forEach(ev => {
                                if (ev.val && ev.val !== '-') {
                                    const isVisible = selectedFieldStates[ev.attr.trim()] !== false;
                                    if (isVisible) {
                                        const itemDiv = document.createElement('div');
                                        itemDiv.className = 'field-item';
                                        itemDiv.innerHTML = `<div class="field-label">${ev.attr}</div><div class="field-value">${ev.val}</div>`;
                                        contentDiv.appendChild(itemDiv);
                                        hasContent = true;
                                    }
                                }
                            });
                        } else {
                            // WIDE format Logic Improvement
                            // 1. Log-style (Value contains date)
                            const hasDateInMonth = Object.values(person).some(v => {
                                if (typeof v !== 'string') return false;
                                const ms = v.match(/[SRH]?\d+[å¹´./-]\d+/g);
                                return ms && ms.some(m => parseJapaneseDate(m)?.label === p.label);
                            });

                            availableFields.forEach(f => {
                                if (selectedFieldStates[f.key] === false) return;
                                const val = person[f.key];
                                if (!val || val === '-') return;

                                // 2. Cross-table-style (Field key is a date matching current column)
                                const fieldDate = parseJapaneseDate(f.key);
                                const isDateMatch = fieldDate && fieldDate.label === p.label;

                                if (hasDateInMonth || isDateMatch) {
                                    const itemDiv = document.createElement('div');
                                    itemDiv.className = 'field-item';
                                    const labelHtml = isDateMatch ? "" : `<div class="field-label">${f.key}</div>`;
                                    itemDiv.innerHTML = `${labelHtml}<div class="field-value">${val}</div>`;
                                    contentDiv.appendChild(itemDiv);
                                    hasContent = true;
                                }
                            });
                        }
                        if (hasContent) cell.appendChild(contentDiv);
                        row.appendChild(cell);
                    });
                    tbody.appendChild(row);
                });

                // Sync Top Scrollbar Width
                setTimeout(() => {
                    const table = document.getElementById('timelineTable');
                    const dummy = document.getElementById('topScrollDummy');
                    const topScroll = document.getElementById('topScrollContainer');
                    const bottomScroll = document.querySelector('.timeline-container');

                    dummy.style.width = table.offsetWidth + 'px';

                    // Auto-scroll to the end (right) on initial render/update
                    topScroll.scrollLeft = topScroll.scrollWidth;
                    bottomScroll.scrollLeft = bottomScroll.scrollWidth;
                }, 0);
            } catch (e) {
                console.error('Render error:', e);
            }
        }

        async function clearData() {
            if (!confirm('ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
            document.getElementById('dataInput').value = '';
            document.getElementById('fieldSelector').innerHTML = '<p style="color: #a0aec0; font-style: italic;">ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€ã¨é …ç›®ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</p>';
            document.getElementById('fieldSelector').dataset.lastKeys = '';
            document.getElementById('tableHeader').innerHTML = '';
            document.getElementById('tableBody').innerHTML = '<tr><td colspan="100" class="no-data">ä¸Šã«ãƒ‡ãƒ¼ã‚¿ã‚’å…¥åŠ›ã™ã‚‹ã¨ã€è‡ªå‹•çš„ã«ã‚¿ã‚¤ãƒ ãƒ†ãƒ¼ãƒ–ãƒ«ãŒç”Ÿæˆã•ã‚Œã¾ã™</td></tr>';
            parsedData = []; availableFields = []; selectedFieldStates = {};
            try {
                const db = await getDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                tx.objectStore(STORE_NAME).delete(DATA_KEY);
                tx.objectStore(STORE_NAME).delete(SETTINGS_KEY);
            } catch (e) {
                console.error('Failed to clear data:', e);
            }
        }

        function copyTableAsCSV(btn) {
            const header = Array.from(document.querySelectorAll('#tableHeader th')).map(th => th.textContent);
            const rows = Array.from(document.querySelectorAll('#tableBody tr'));

            let csv = header.map(h => `"${h.replace(/"/g, '""')}"`).join(',') + '\n';

            rows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td'));
                const rowData = cells.map(td => {
                    // Extract text content from all items in the cell
                    const items = Array.from(td.querySelectorAll('.field-item')).map(item => {
                        const label = item.querySelector('.field-label')?.textContent || '';
                        const val = item.querySelector('.field-value')?.textContent || '';
                        return label ? `${label}:${val}` : val;
                    });
                    const text = items.length > 0 ? items.join(' | ') : td.textContent;
                    return `"${text.replace(/"/g, '""')}"`;
                });
                csv += rowData.join(',') + '\n';
            });

            navigator.clipboard.writeText(csv).then(() => {
                const originalText = btn.innerHTML;
                btn.innerHTML = 'âœ… ã‚³ãƒ”ãƒ¼å®Œäº†ï¼';
                btn.style.background = '#38a169';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = '#48bb78';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy CSV:', err);
                alert('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚è©³ç´°ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            });
        }

        function setToToday() {
            const today = new Date();
            const yyyy = today.getFullYear();
            const mm = String(today.getMonth() + 1).padStart(2, '0');
            const dd = String(today.getDate()).padStart(2, '0');
            document.getElementById('referenceDate').value = `${yyyy}-${mm}-${dd}`;

            if (!isInitialLoading) {
                if (selectedFieldStates) {
                    selectedFieldStates._referenceDate = document.getElementById('referenceDate').value;
                    saveSettingsToDB(selectedFieldStates);
                }
                generateTimeline(true);
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            loadDataFromDB();
            document.getElementById('fileInput').addEventListener('change', function (e) {
                isInitialLoading = false; // User started interaction
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        document.getElementById('dataInput').value = ev.target.result;
                        generateTimeline();
                    };
                    reader.readAsText(file);
                    e.target.value = ''; // Reset to allow re-selection of the same file
                }
            });
            document.getElementById('dataInput').addEventListener('dblclick', () => {
                document.getElementById('fileInput').click();
            });
            // Live save and render on input
            let renderTimeout = null;
            document.getElementById('dataInput').addEventListener('input', (e) => {
                const val = e.target.value;
                saveDataToDB(val);
                if (renderTimeout) clearTimeout(renderTimeout);
                renderTimeout = setTimeout(() => {
                    generateTimeline();
                }, 500); // Faster update (0.5s)
            });

            // Sync Scrolling
            const topScroll = document.getElementById('topScrollContainer');
            const bottomScroll = document.querySelector('.timeline-container');

            topScroll.addEventListener('scroll', () => {
                bottomScroll.scrollLeft = topScroll.scrollLeft;
            });
            bottomScroll.addEventListener('scroll', () => {
                topScroll.scrollLeft = bottomScroll.scrollLeft;
            });
        });
    </script>
</body>

</html>